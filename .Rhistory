sds <- sqrt(gmm_model$parameters$variance$sigmasq) # Standard deviations of each component
# Create a summary table
summary_table <- data.frame(
Factor = round(mixing_proportions, 3),
Mean = round(means, 2),
`Standard Deviation` = round(sds, 3)
)
# Add row numbers
summary_table <- cbind(No. = 1:nrow(summary_table), summary_table)
# Print the summary table
print(summary_table)
# Generate a sequence of x values for the curve
x_values <- seq(min(dist), max(dist), length.out = 1000)
# Initialize a data frame for the Gaussian mixture model
gmm_df <- data.frame(x = x_values)
# Add columns for each Gaussian component and the total sum
for (i in 1:num_gaussians) {
if (length(sds) == 1) {
# Use the same standard deviation for all Gaussians
gmm_df[[paste0("Gaussian_", i)]] <- mixing_proportions[[i]] * dnorm(x_values, mean = means[[i]], sd = sds)
} else {
# Use the corresponding standard deviation for each Gaussian
gmm_df[[paste0("Gaussian_", i)]] <- mixing_proportions[[i]] * dnorm(x_values, mean = means[[i]], sd = sds[[i]])
}
}
# Add a column for the total mixture density
gmm_df$total_density <- rowSums(gmm_df[2:(num_gaussians + 1)])
# Create the ggplot
p <- ggplot() +
geom_histogram(aes(x = dist, y = ..density..), bins = 30, fill = "grey", alpha = 0.5) +  # Plot the histogram of the data
geom_line(data = gmm_df, aes(x = x, y = total_density), color = "red", size = 1) +       # Plot the sum of Gaussians
theme_minimal() +
labs(title = "Gaussian Mixture Model",
x = "Value",
y = "Density")
return(p)
}
plot_gmm(dist_walk_ped)
plot_gmm(dist_walk_ped, G=5)
plot_gmm(dist_walk_ped, G=3)
plot_gmm(dist_stndng_ped)
df <- freq_tab_stndng_ped
ggplot(df , aes(x=freq)) + xlim(0,8) + stat_density(geom = "line", position = "identity")
plot_gmm <- function(dist, G = NULL) {
# Fit a Gaussian Mixture Model to the provided distribution data
if (is.null(G)) {
gmm_model <- Mclust(dist)  # Let Mclust determine the optimal number of Gaussians
} else {
gmm_model <- Mclust(dist, G = G)  # Use the specified number of Gaussians
}
# Extract parameters from the fitted GMM model
num_gaussians <- gmm_model$G
mixing_proportions <- gmm_model$parameters$pro    # Mixing proportions (factors)
means <- gmm_model$parameters$mean                # Means of each component
sds <- sqrt(gmm_model$parameters$variance$sigmasq) # Standard deviations of each component
# Create a summary table
summary_table <- data.frame(
Factor = round(mixing_proportions, 3),
Mean = round(means, 2),
`Standard Deviation` = round(sds, 3)
)
# Add row numbers
summary_table <- cbind(No. = 1:nrow(summary_table), summary_table)
# Print the summary table
print(summary_table)
# Generate a sequence of x values for the curve
x_values <- seq(min(dist), max(dist), length.out = 1000)
# Initialize a data frame for the Gaussian mixture model
gmm_df <- data.frame(x = x_values)
# Add columns for each Gaussian component and the total sum
for (i in 1:num_gaussians) {
if (length(sds) == 1) {
# Use the same standard deviation for all Gaussians
gmm_df[[paste0("Gaussian_", i)]] <- mixing_proportions[[i]] * dnorm(x_values, mean = means[[i]], sd = sds)
} else {
# Use the corresponding standard deviation for each Gaussian
gmm_df[[paste0("Gaussian_", i)]] <- mixing_proportions[[i]] * dnorm(x_values, mean = means[[i]], sd = sds[[i]])
}
}
# Add a column for the total mixture density
gmm_df$total_density <- rowSums(gmm_df[2:(num_gaussians + 1)])
# Create the ggplot
p <- ggplot() +
geom_histogram(aes(x = dist, y = ..density..), bins = 30, fill = "grey", alpha = 0.5) +  # Plot the histogram of the data
geom_line(data = gmm_df, aes(x = x, y = total_density), color = "red", size = 1) +       # Plot the sum of Gaussians
geom_density(aes(x = dist), color = "blue", linetype = "dotted", size = 1) +             # Plot the KDE as a dotted line
theme_minimal() +
labs(title = "Gaussian Mixture Model vs Kernel Density Estimate",
x = "Value",
y = "Density")
return(p)
}
plot_gmm(dist_stndng_ped)
plot_gmm(dist_stndng_ped, 3)
plot_gmm(dist_stndng_ped, 4)
plot_gmm(dist_stndng_ped, 5)
plot_gmm(dist_stndng_ped, 6)
plot_gmm(dist_stndng_ped, 7)
plot_gmm(dist_stndng_ped, 5)
plot_gmm(dist_parked_car)
plot_gmm(dist_parked_car, 6)
plot_gmm(dist_parked_rck)
plot_gmm(dist_parked_rck, 5)
plot_gmm(dist_parked_rck, 4)
plot_gmm(dist_parked_rck, 3)
plot_gmm(dist_parked_rck, 2)
plot_gmm(dist_parked_rck, 1)
plot_gmm(dist_parked_rck, 6)
plot_gmm(dist_parked_rck, 7)
plot_gmm(dist_parked_rck, 8)
plot_gmm(dist_parked_rck, 9)
plot_gmm(dist_parked_rck, 10)
plot_gmm(dist_parked_rck, 7)
plot_gmm(dist_parked_rck, 5)
plot_gmm(dist_parked_rck, 4)
plot_gmm(dist_parked_rck, 3)
plot_gmm(dist_parked_rck)
#libraries needed
library(tidyverse)
library(mixtools)
library(ghibli) #' if I want to look less professional by having
#just a plotting theme
ggplot2::theme_set(
theme_bw() +
theme(
plot.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
panel.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
plot.title = element_text(size = 14),
axis.title = element_text(size = 14, colour = ghibli_palettes$PonyoDark[7]),
axis.text = element_text(size = 12, colour = ghibli_palettes$PonyoDark[7]),
panel.grid = element_blank()
)
)
install.packages(tidyverse)
install.packages(mixtools)
install.packages("tidyverse")
install.packages("mixtools")
install.packages(ghibli)
install.packages("ghibli")
#libraries needed
library(tidyverse)
library(mixtools)
library(ghibli) #' if I want to look less professional by having
#just a plotting theme
ggplot2::theme_set(
theme_bw() +
theme(
plot.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
panel.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
plot.title = element_text(size = 14),
axis.title = element_text(size = 14, colour = ghibli_palettes$PonyoDark[7]),
axis.text = element_text(size = 12, colour = ghibli_palettes$PonyoDark[7]),
panel.grid = element_blank()
)
)
#simulate a dataset
set.seed(12) #better make this reproducible
observations <- tibble(value = c(
rnorm(n = 1000, mean = 0.1, sd = 0.1),
rnorm(n = 4000, mean = 0.5, sd = 0.4),
rnorm(n = 3000, mean = 0.9, sd = 0.1)
)
)
#model the dataset with multiple gaussians
my_mix <- normalmixEM(observations$value, k = 3)
install.packages("installr")
library(installr)
updateR()
updateR()
#libraries needed
library(tidyverse)
library(mixtools)
library(ghibli) #' if I want to look less professional by having
#just a plotting theme
ggplot2::theme_set(
theme_bw() +
theme(
plot.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
panel.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
plot.title = element_text(size = 14),
axis.title = element_text(size = 14, colour = ghibli_palettes$PonyoDark[7]),
axis.text = element_text(size = 12, colour = ghibli_palettes$PonyoDark[7]),
panel.grid = element_blank()
)
)
#simulate a dataset
set.seed(12) #better make this reproducible
#libraries needed
library(tidyverse)
library(mixtools)
library(ghibli) #' if I want to look less professional by having
#just a plotting theme
ggplot2::theme_set(
theme_bw() +
theme(
plot.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
panel.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
plot.title = element_text(size = 14),
axis.title = element_text(size = 14, colour = ghibli_palettes$PonyoDark[7]),
axis.text = element_text(size = 12, colour = ghibli_palettes$PonyoDark[7]),
panel.grid = element_blank()
)
)
#simulate a dataset
set.seed(12) #better make this reproducible
observations <- tibble(value = c(
rnorm(n = 1000, mean = 0.1, sd = 0.1),
rnorm(n = 4000, mean = 0.5, sd = 0.4),
rnorm(n = 3000, mean = 0.9, sd = 0.1)
)
)
#model the dataset with multiple gaussians
my_mix <- normalmixEM(observations$value, k = 3)
#libraries needed
library(tidyverse)
library(mixtools)
library(ghibli) #' if I want to look less professional by having
#just a plotting theme
ggplot2::theme_set(
theme_bw() +
theme(
plot.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
panel.background = element_rect(fill = ghibli_palettes$PonyoLight[7]),
plot.title = element_text(size = 14),
axis.title = element_text(size = 14, colour = ghibli_palettes$PonyoDark[7]),
axis.text = element_text(size = 12, colour = ghibli_palettes$PonyoDark[7]),
panel.grid = element_blank()
)
)
#simulate a dataset
set.seed(12) #better make this reproducible
observations <- tibble(value = c(
rnorm(n = 1000, mean = 0.1, sd = 0.1),
rnorm(n = 4000, mean = 0.5, sd = 0.4),
rnorm(n = 3000, mean = 0.9, sd = 0.1)
)
)
#model the dataset with multiple gaussians
my_mix <- normalmixEM(observations$value, k = 3)
#plot the data and the model
ggplot(observations, aes(x = value)) +
geom_histogram(binwidth = 0.05, fill = ghibli_palettes$PonyoMedium[2]) +
mapply(function(mean, sd, lambda, n, binwidth, colour) {
stat_function(
fun = function(x) {
(dnorm(x, mean = mean, sd = sd)) * n * binwidth * lambda
},
colour = colour, #this is just to make it pretty
size = 1
)
},
mean = my_mix[["mu"]],
sd = my_mix[["sigma"]],
lambda = my_mix[["lambda"]],
n = length(observations$value),
binwidth = 0.05,
colour = c(ghibli_palettes$PonyoMedium[3],
ghibli_palettes$PonyoMedium[4],
ghibli_palettes$PonyoMedium[5])
)
proportional_gauss <- function(x, mean, sd, lambda, n, binwidth) {
(dnorm(x, mean = mean, sd = sd)) * n * binwidth * lambda
}
proportional_gauss_sum <- function(x, mean, sd, lambda, n, binwidth) {
apply(mapply(proportional_gauss,
x = x,
MoreArgs = list( mean, sd, lambda, n, binwidth)
),
2, sum)
}
ggplot(observations, aes(x = value)) +
geom_histogram(binwidth = 0.05, fill = ghibli_palettes$PonyoMedium[2]) +
stat_function(
fun = proportional_gauss_sum,
args = list(
mean = my_mix[["mu"]],
sd = my_mix[["sigma"]],
lambda = my_mix[["lambda"]],
n = length(observations$value),
binwidth = 0.05
),
colour = ghibli_palettes$PonyoMedium[5], size = 1
)
curve_function <- function(x, dist, G=NULL) {
if (is.null(G)) {
gmm_model <- Mclust(dist)
} else {
gmm_model <- Mclust(dist, G = G)
}
num_gaussians <- gmm_model$G
mixing_proportions <- gmm_model$parameters$pro    # Mixing proportions (factors)
means <- gmm_model$parameters$mean                # Means of each component
sds <- sqrt(gmm_model$parameters$variance$sigmasq) # Standard deviations of each component
# Create a summary table
summary_table <- data.frame(
Factor = round(mixing_proportions, 3),
Mean = round(means, 2),
`Standard Deviation` = round(sds, 3)
)
summary_table <- cbind(No. = 1:nrow(summary_table), summary_table)
print(summary_table)
result <- 0
for (i in 1:num_gaussians) {
if (length(sds) == 1) {
# Use the same standard deviation for all Gaussians
result <- result + mixing_proportions[[i]] * dnorm(x, mean = means[[i]], sd = sds)
} else {
# Use the corresponding standard deviation for each Gaussian
result <- result + mixing_proportions[[i]] * dnorm(x, mean = means[[i]], sd = sds[[i]])
}
}
return(result)
}
proportional_gauss <- function(x, mean, sd, lambda, n, binwidth) {
(dnorm(x, mean = mean, sd = sd)) * n * binwidth * lambda
}
proportional_gauss_sum <- function(x, mean, sd, lambda, n, binwidth) {
apply(mapply(proportional_gauss,
x = x,
MoreArgs = list(mean, sd, lambda, n, binwidth)
),
2, sum)
}
# Plotting function
plot_gmm <- function(dist, G = NULL) {
# Fit GMM
gmm_model <- Mclust(dist, G = G)
# Get parameters
num_gaussians <- gmm_model$G
mixing_proportions <- gmm_model$parameters$pro    # Mixing proportions (factors)
means <- gmm_model$parameters$mean                # Means of each component
sds <- sqrt(gmm_model$parameters$variance$sigmasq) # Standard deviations of each component
# Create summary table
summary_table <- data.frame(
Factor = round(mixing_proportions, 3),
Mean = round(means, 2),
`Standard Deviation` = round(sds, 3)
)
# Add row numbers
summary_table <- cbind(No. = 1:nrow(summary_table), summary_table)
# Print summary table
print(summary_table)
# Create data frame for observations
observations <- data.frame(value = dist)
# Create the plot
ggplot(observations, aes(x = value)) +
geom_histogram(binwidth = 0.05, fill = ghibli_palettes$PonyoMedium[2], alpha = 0.7) +
stat_function(
fun = proportional_gauss_sum,
args = list(
mean = means,
sd = sds,
lambda = mixing_proportions,
n = length(dist),
binwidth = 0.05
),
colour = ghibli_palettes$PonyoMedium[5], size = 1
) +
stat_function(
fun = density,
colour = "black", size = 1, linetype = "dotted"
) +
theme_minimal() +
labs(
title = "Gaussian Mixture Model Fitting",
x = "Value",
y = "Density"
) +
theme(
plot.title = element_text(size = 16, face = "bold"),
axis.title = element_text(size = 14),
axis.text = element_text(size = 12)
)
}
plot_gmm(dist_stndng_ped, 5)
curve_function <- function(x, dist, G=NULL) {
if (is.null(G)) {
gmm_model <- Mclust(dist)
} else {
gmm_model <- Mclust(dist, G = G)
}
num_gaussians <- gmm_model$G
mixing_proportions <- gmm_model$parameters$pro    # Mixing proportions (factors)
means <- gmm_model$parameters$mean                # Means of each component
sds <- sqrt(gmm_model$parameters$variance$sigmasq) # Standard deviations of each component
# Create a summary table
summary_table <- data.frame(
Factor = round(mixing_proportions, 3),
Mean = round(means, 2),
`Standard Deviation` = round(sds, 3)
)
summary_table <- cbind(No. = 1:nrow(summary_table), summary_table)
print(summary_table)
result <- 0
for (i in 1:num_gaussians) {
if (length(sds) == 1) {
# Use the same standard deviation for all Gaussians
result <- result + mixing_proportions[[i]] * dnorm(x, mean = means[[i]], sd = sds)
} else {
# Use the corresponding standard deviation for each Gaussian
result <- result + mixing_proportions[[i]] * dnorm(x, mean = means[[i]], sd = sds[[i]])
}
}
return(result)
}
plot_gmm <- function(dist, G = NULL) {
# Fit a Gaussian Mixture Model to the provided distribution data
if (is.null(G)) {
gmm_model <- Mclust(dist)  # Let Mclust determine the optimal number of Gaussians
} else {
gmm_model <- Mclust(dist, G = G)  # Use the specified number of Gaussians
}
# Extract parameters from the fitted GMM model
num_gaussians <- gmm_model$G
mixing_proportions <- gmm_model$parameters$pro    # Mixing proportions (factors)
means <- gmm_model$parameters$mean                # Means of each component
sds <- sqrt(gmm_model$parameters$variance$sigmasq) # Standard deviations of each component
# Create a summary table
summary_table <- data.frame(
Factor = round(mixing_proportions, 3),
Mean = round(means, 2),
`Standard Deviation` = round(sds, 3)
)
# Add row numbers
summary_table <- cbind(No. = 1:nrow(summary_table), summary_table)
# Print the summary table
print(summary_table)
# Generate a sequence of x values for the curve
x_values <- seq(min(dist), max(dist), length.out = 1000)
# Initialize a data frame for the Gaussian mixture model
gmm_df <- data.frame(x = x_values)
# Add columns for each Gaussian component and the total sum
for (i in 1:num_gaussians) {
if (length(sds) == 1) {
# Use the same standard deviation for all Gaussians
gmm_df[[paste0("Gaussian_", i)]] <- mixing_proportions[[i]] * dnorm(x_values, mean = means[[i]], sd = sds)
} else {
# Use the corresponding standard deviation for each Gaussian
gmm_df[[paste0("Gaussian_", i)]] <- mixing_proportions[[i]] * dnorm(x_values, mean = means[[i]], sd = sds[[i]])
}
}
# Add a column for the total mixture density
gmm_df$total_density <- rowSums(gmm_df[2:(num_gaussians + 1)])
# Create the ggplot
p <- ggplot() +
geom_histogram(aes(x = dist, y = ..density..), bins = 30, fill = "grey", alpha = 0.5) +  # Plot the histogram of the data
geom_line(data = gmm_df, aes(x = x, y = total_density), color = "red", size = 1) +       # Plot the sum of Gaussians
geom_density(aes(x = dist), color = "blue", linetype = "dotted", size = 1) +             # Plot the KDE as a dotted line
theme_minimal() +
labs(title = "Gaussian Mixture Model vs Kernel Density Estimate",
x = "Value",
y = "Density")
return(p)
}
plot_gmm(dist_stndng_ped, 5)
curve(curve_function(x, dist_stndng_ped, 5), col = "red", lwd = 2, add = TRUE)
curve(curve_function(x, dist_stndng_ped, 5), col = "red", lwd = 2, add = TRUE)
plot_gmm(dist_parked_car, 6)
plot_gmm(dist_parked_rck)
plot_gmm(dist_parked_rck, 5)
plot_gmm(dist_parked_cng, 4)
plot_gmm(dist_parked_cng, 3)
plot_gmm(dist_parked_cng, 2)
plot_gmm(dist_walk_ped)
plot_gmm(dist_walk_ped, 5)
plot_gmm(dist_walk_ped, 4)
plot_gmm(dist_walk_ped, 2)
plot_gmm(dist_walk_ped, 3)
# Distribution of Parked car
par(mar=c(6,7,1,1)+.1, xpd = FALSE)
plot(density(dist_parked_car), lwd=4, family = "A",font = 1, lty = 5, cex.lab = 3,cex.main = 3,cex.axis = 2.5,
main = "",
xlab="",
ylab="",
xlim = c(0,6),
ylim = c(0, 0.7),
xaxs = "i",
yaxs = "i")
abline(h = 0)           # without this line, x axis appear gridded (density func is spooky. using ggplot is recommended)
grid(nx = NULL, ny = NULL,
lty = 2,      # Grid line type
col = "black", # Grid line color
lwd = 1.5)
title(xlab = "Blockage of road (m)", family = "A", line = 4.5 , cex.lab=3)
title(ylab="Probability density", family = "A", line = 4.5,cex.lab=3)
# Distribution of parked cars
curve(
+0.050*dnorm(x,mean=1.12,sd=0.390)
+0.515*dnorm(x,mean=2.07,sd=0.322)
+0.200*dnorm(x,mean=2.73,sd=0.310)
+0.172*dnorm(x,mean=3.64,sd=0.334)
+0.042*dnorm(x,mean=4.48,sd=0.300)
+0.010*dnorm(x,mean=5.92,sd=0.310),
col="red", lwd=2, add=TRUE)
plot_gmm(dist_parked_car, 6)
plot_gmm(dist_parked_cng, 4)
plot_gmm(dist_walk_ped, 3)
plot_gmm(dist_walk_ped, 2)
plot_gmm(dist_walk_ped, 1)
plot_gmm(dist_walk_ped, 3)
plot_gmm(dist_walk_ped, 2)
plot_gmm(dist_parked_car, 6)
plot_gmm(dist_stndng_ped, 5)
plot_gmm(dist_parked_car, 6)
library(mixtools)
library(flemix)
install.packages(flemix)
install.packages("flemix")
install.packages("flexmix")
library(mixtools)
library(flexmix)
R --version
